{"version":3,"sources":["enums/EditStatus.ts","components/EditStatusWidget.tsx","enums/JSONPatchOperationType.ts","services/ApiService.ts","enums/FieldEditorType.ts","components/FieldEditor.tsx","hooks/useDebounce.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["EditStatus","EditStatusWidget","props","status","Idle","Saving","className","role","aria-label","Saved","Error","JSONPatchOperationType","ApiService","endpoint","redirectUri","headers","this","replace","Headers","Accept","method","uri","fetch","response","ensureValidResponse","data","success","failed","init","body","JSON","stringify","redirect","ok","json","error","FieldEditorType","FieldEditor","id","value","label","showLabel","propertyName","type","useState","currentValue","setCurrentValue","lastValue","setLastValue","editState","setEditState","debouncedValue","delay","setDebouncedValue","useEffect","handler","setTimeout","clearTimeout","useDebounce","apiService","a","requestObject","op","Replace","path","patch","saveValue","fieldKey","cssClass","undefined","htmlFor","Input","placeholder","name","onChange","e","target","Textarea","App","widget","setWidget","fetchWidget","get","model","title","description","Boolean","window","location","hostname","match","baseUrl","document","getElementsByTagName","getAttribute","rootElement","getElementById","ReactDOM","render","basename","navigator","serviceWorker","ready","then","registration","unregister","catch","console","message"],"mappings":"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","file":"static/js/main.66cb10f9.chunk.js","sourcesContent":["export enum EditStatus {\n    Idle,\n    Saving,\n    Error,\n    Saved\n}","import * as React from 'react';\nimport { EditStatus } from '../enums/EditStatus';\n\nexport interface IEditStatusWidgetProps {\n    status: EditStatus;\n}\n\nexport function EditStatusWidget(props: IEditStatusWidgetProps) {\n    switch (props.status) {\n        case EditStatus.Idle:\n            return <></>\n        case EditStatus.Saving:\n            return <div className=\"text-muted pt-2\"><span role=\"img\" aria-label=\"Saving\">ðŸ”„</span> Saving...</div>;\n        case EditStatus.Saved:\n            return <div className=\"text-muted pt-2\"><span role=\"img\" aria-label=\"Green Check\">âœ…</span> Saved!</div>;\n        case EditStatus.Error:\n            return <div className=\"text-muted pt-2\"><span role=\"img\" aria-label=\"Explode\">ðŸ’¥</span> There was an error saving!</div>;\n        default:\n            throw Error(`Status not handled ${props.status}.`);\n    }\n}\n","/**\n * @description RFC 6902 compliant enum for allowed JSON Patch operations. See http://jsonpatch.com/ for details.\n */\nenum JSONPatchOperationType {\n    Add = \"add\",\n    Remove = \"remove\",\n    Replace = \"replace\",\n    Copy = \"copy\",\n    Move = \"move\",\n    Test = \"test\"\n}\n\nexport default JSONPatchOperationType;\n","export class ApiService {\n\n    private readonly endpoint: string;\n    private readonly headers: Headers;\n    private readonly redirectUri: string | null;\n\n    constructor(endpoint: string, redirectUri: string | null = null) {\n        this.redirectUri = redirectUri;\n        this.endpoint = `/api/${endpoint}`.replace(\"//\", \"/\");\n        this.headers = new Headers({\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/json\",\n        });\n    }\n\n    public async get<T>(method: string | null = null): Promise<T> {\n        const uri = this.endpoint + (method === null ? '' : '/' + method);\n        const response = await fetch(uri);\n        return this.ensureValidResponse<T>(response);\n    }\n\n    public async patch(data: any, success: () => void, failed: (value: any) => void): Promise<void> {\n        const init: RequestInit = {\n            method: \"PATCH\",\n            body: JSON.stringify(data),\n            redirect: \"follow\",\n            headers: this.headers\n        };\n\n        const response = await fetch(this.endpoint, init);\n        if (response.ok) {\n            success();\n        } else {\n            try {\n                var error = (await response.json()) as any;\n                failed(error);\n            } catch {\n                failed(\"Unknown error.\");\n            }\n        }\n    }\n\n    private async ensureValidResponse<T>(response: Response): Promise<T> {\n        if (!response.ok) {\n            throw Error(`Request to ${this.endpoint} failed.`);\n        }\n\n        return (await response.json()) as T;\n    }\n}\n","export enum FieldEditorType {\n    Input,\n    Textarea,\n    Date\n}\n","import * as React from 'react';\nimport { useState, useEffect } from 'react';\nimport useDebounce from '../hooks/useDebounce';\nimport { EditStatus } from '../enums/EditStatus';\nimport { EditStatusWidget } from './EditStatusWidget';\nimport { ApiService } from '../services/ApiService';\nimport JSONPatchOperation from '../interfaces/JSONPatchOperation';\nimport JSONPatchOperationType from '../enums/JSONPatchOperationType';\nimport { FieldEditorType } from '../enums/FieldEditorType';\n\ninterface IFieldEditorProps {\n    value: string;\n    id: string;\n    label: string;\n    propertyName: string;\n    endpoint: string;\n    type: FieldEditorType;\n    showLabel?: boolean;\n    created?: Date;\n}\n\nexport default function FieldEditor(props: IFieldEditorProps) {\n    const { id, value, label, showLabel, propertyName, endpoint, type } = props;\n    const [currentValue, setCurrentValue] = useState<string>(value);\n    const [lastValue, setLastValue] = useState<string>(value);\n    const [editState, setEditState] = useState<EditStatus>(EditStatus.Idle);\n    const debouncedValue = useDebounce(currentValue, 500);\n    const apiService = new ApiService(endpoint);\n\n    useEffect(() => {\n        async function saveValue() {\n            // if they haven't picked an image yet, we can't update its title or comments (need an id to PATCH)\n            if (id === '') {\n                return;\n            }\n            // Make sure we have a value (user has entered something in input)\n            if (debouncedValue !== lastValue) {\n                setLastValue(debouncedValue);\n\n                // Dynamically create the JSON patch object based on the field changed\n                let requestObject: JSONPatchOperation[] = [{\n                    op: JSONPatchOperationType.Replace,\n                    path: propertyName,\n                    value: debouncedValue\n                }];\n\n                await apiService.patch(\n                    requestObject,\n                    () => {\n                        setEditState(EditStatus.Saved);\n                        setTimeout(() => setEditState(EditStatus.Idle), 1500)\n                    },\n                    (error) => {\n                        setEditState(EditStatus.Error);\n                    }\n                );\n            }\n        }\n        saveValue();\n    });\n\n    // Unique key for identifying this field\n    const fieldKey = `key_${id}_${propertyName}`;\n    const cssClass = `form-control ${editState === EditStatus.Error ? ' is-invalid' : ''}`;\n\n    return (\n        <div className=\"form-group\">\n            {(showLabel || showLabel === undefined) &&\n                <label className=\"text-muted\" htmlFor={fieldKey}>{label}</label>\n            }\n            {type === FieldEditorType.Input && (\n                <input\n                    type=\"text\"\n                    id={fieldKey}\n                    placeholder={label}\n                    name={fieldKey}\n                    className={cssClass}\n                    value={currentValue ?? \"\"}\n                    onChange={(e: React.ChangeEvent<HTMLInputElement>) => { setEditState(EditStatus.Saving); setCurrentValue(e.target.value) }}\n                />\n            )}\n            {type === FieldEditorType.Textarea && (\n                <textarea\n                    id={fieldKey}\n                    placeholder={label}\n                    name={fieldKey}\n                    className={cssClass}\n                    value={currentValue ?? \"\"}\n                    onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => { setEditState(EditStatus.Saving); setCurrentValue(e.target.value) }}\n                />\n            )}\n            <EditStatusWidget status={editState} />\n        </div>\n    );\n}\n","import { useState, useEffect } from 'react';\n\n// From https://dev.to/gabe_ragland/debouncing-with-react-hooks-jci\nexport default function useDebounce(value: any, delay: number) {\n    const [debouncedValue, setDebouncedValue] = useState(value);\n\n    useEffect(\n        () => {\n            const handler = setTimeout(() => {\n                setDebouncedValue(value);\n            }, delay);\n\n            return () => {\n                clearTimeout(handler);\n            };\n        }\n    );\n\n    return debouncedValue;\n}\n","import React, { useEffect, useState } from 'react';\r\nimport FieldEditor from './components/FieldEditor';\r\nimport './custom.css'\r\nimport { FieldEditorType } from './enums/FieldEditorType';\r\nimport WidgetModel from './interfaces/WidgetModel';\r\nimport { ApiService } from './services/ApiService';\r\n\r\nexport default function App() {\r\n  // ID hardcoded here as example\r\n  const id = \"00dd1425-bfc7-4a60-b96b-de080c8c82db\";\r\n  const [widget, setWidget] = useState<WidgetModel | null>(null);\r\n  const apiService = new ApiService(`widget/${id}`);\r\n\r\n  const fetchWidget = async () => {\r\n    const model = await apiService.get<WidgetModel>();  \r\n      setWidget(model);                 \r\n  }\r\n\r\n  useEffect(() => {\r\n    if (widget === null) {\r\n      fetchWidget();\r\n    }\r\n  })\r\n\r\n  if (widget === null) {\r\n    return <p>Loading...</p>\r\n  }\r\n  \r\n  return (\r\n    <div className=\"container-fluid\">\r\n      <div className=\"row p-4\">\r\n        <div className=\"col-md-6\">\r\n          <p className=\"text-muted\">Editing Widget ID <b>{widget.id}</b></p>\r\n          <FieldEditor\r\n            id={widget.id}\r\n            value={widget.title}\r\n            type={FieldEditorType.Input}\r\n            label=\"Titel:\"\r\n            propertyName=\"Title\"\r\n            endpoint={`widget/${id}`}\r\n          />\r\n          <FieldEditor\r\n            id={widget.id}\r\n            value={widget.description}\r\n            type={FieldEditorType.Textarea}\r\n            label=\"Description:\"\r\n            propertyName=\"Description\"\r\n            endpoint={`widget/${id}`}\r\n          />\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n  // [::1] is the IPv6 localhost address.\r\n  window.location.hostname === '[::1]' ||\r\n  // 127.0.0.0/8 are considered localhost for IPv4.\r\n  window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n  )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n      // The URL constructor is available in all browsers that support SW.\r\n      const publicUrl = new URL(\r\n          process.env.PUBLIC_URL,\r\n          window.location.href\r\n      );\r\n      if (publicUrl.origin !== window.location.origin) {\r\n          // Our service worker won't work if PUBLIC_URL is on a different origin\r\n          // from what our page is served on. This might happen if a CDN is used to\r\n          // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n          return;\r\n      }\r\n\r\n      window.addEventListener('load',\r\n          () => {\r\n              const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n              if (isLocalhost) {\r\n                  // This is running on localhost. Let's check if a service worker still exists or not.\r\n                  checkValidServiceWorker(swUrl, config);\r\n\r\n                  // Add some additional logging to localhost, pointing developers to the\r\n                  // service worker/PWA documentation.\r\n                  navigator.serviceWorker.ready.then(() => {\r\n                      console.log(\r\n                          'This web app is being served cache-first by a service ' +\r\n                          'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n                      );\r\n                  });\r\n              } else {\r\n                  // Is not localhost. Just register service worker\r\n                  registerValidSW(swUrl, config);\r\n              }\r\n          });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n      .register(swUrl)\r\n      .then(registration => {\r\n          registration.onupdatefound = () => {\r\n              const installingWorker = registration.installing;\r\n              if (installingWorker == null) {\r\n                  return;\r\n              }\r\n              installingWorker.onstatechange = () => {\r\n                  if (installingWorker.state === 'installed') {\r\n                      if (navigator.serviceWorker.controller) {\r\n                          // At this point, the updated precached content has been fetched,\r\n                          // but the previous service worker will still serve the older\r\n                          // content until all client tabs are closed.\r\n                          console.log(\r\n                              'New content is available and will be used when all ' +\r\n                              'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n                          );\r\n\r\n                          // Execute callback\r\n                          if (config && config.onUpdate) {\r\n                              config.onUpdate(registration);\r\n                          }\r\n                      } else {\r\n                          // At this point, everything has been precached.\r\n                          // It's the perfect time to display a\r\n                          // \"Content is cached for offline use.\" message.\r\n                          console.log('Content is cached for offline use.');\r\n\r\n                          // Execute callback\r\n                          if (config && config.onSuccess) {\r\n                              config.onSuccess(registration);\r\n                          }\r\n                      }\r\n                  }\r\n              };\r\n          };\r\n      })\r\n      .catch(error => {\r\n          console.error('Error during service worker registration:', error);\r\n      });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl,\r\n          {\r\n              headers: { 'Service-Worker': 'script' }\r\n          })\r\n      .then(response => {\r\n          // Ensure service worker exists, and that we really are getting a JS file.\r\n          const contentType = response.headers.get('content-type');\r\n          if (\r\n              response.status === 404 ||\r\n                  (contentType != null && contentType.indexOf('javascript') === -1)\r\n          ) {\r\n              // No service worker found. Probably a different app. Reload the page.\r\n              navigator.serviceWorker.ready.then(registration => {\r\n                  registration.unregister().then(() => {\r\n                      window.location.reload();\r\n                  });\r\n              });\r\n          } else {\r\n              // Service worker found. Proceed as normal.\r\n              registerValidSW(swUrl, config);\r\n          }\r\n      })\r\n      .catch(() => {\r\n          console.log(\r\n              'No internet connection found. App is running in offline mode.'\r\n          );\r\n      });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n      navigator.serviceWorker.ready\r\n          .then(registration => {\r\n              registration.unregister();\r\n          })\r\n          .catch(error => {\r\n              console.error(error.message);\r\n          });\r\n  }\r\n}","import 'bootstrap/dist/css/bootstrap.css';\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { BrowserRouter } from 'react-router-dom';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nconst baseUrl = document.getElementsByTagName('base')[0].getAttribute('href') || undefined;\r\nconst rootElement = document.getElementById('root');\r\n\r\nReactDOM.render(\r\n  <BrowserRouter basename={baseUrl}>\r\n    <App />\r\n  </BrowserRouter>,\r\n  rootElement);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n\r\n"],"sourceRoot":""}